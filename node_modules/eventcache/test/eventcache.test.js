var assert = require("assert"),
	EventCache = require("../build/eventcache"),
	EventDispatcher = require("@vanruesc/eventdispatcher");

describe("EventCache", function() {

	describe("Sanity checks", function() {

		it("should be an object", function() {

			assert.equal(typeof EventCache, "object");

		});

		it("should have a createCache() method", function() {

			assert.equal(typeof EventCache.createCache, "function");

		});

		it("should have a bind() method", function() {

			assert.equal(typeof EventCache.bind, "function");

		});

		it("should have a unbind() method", function() {

			assert.equal(typeof EventCache.unbind, "function");

		});

		it("should have a flush() method", function() {

			assert.equal(typeof EventCache.flush, "function");

		});

		it("should have a status() method", function() {

			assert.equal(typeof EventCache.status, "function");

		});

	});

	describe("Functionality", function() {

		describe("Creating a cache", function() {

			it("should yield a new event cache reference", function() {

				assert.equal(EventCache.createCache(), 1);
				assert.equal(EventCache.status().additionalCaches.length, 1);

			});

		});

		describe("Flushing without specifying a cache", function() {

			it("should remove all caches except the default one", function() {

				EventCache.createCache();
				EventCache.flush();
				assert.equal(EventCache.status().additionalCaches.length, 0);

			});

		});

		describe("Flushing a specific cache", function() {

			it("should clear the specified cache", function() {

				var cache = EventCache.createCache();
				EventCache.bind({}, "test", function() {});
				EventCache.flush(cache);
				assert.equal(EventCache.status().additionalCaches[cache - 1].length, 0);

			});

		});

		describe("Binding without specifying a cache", function() {

			it("should store the signature in the default cache", function() {

				EventCache.bind({}, "test", function() {});
				assert.equal(EventCache.status().defaultCache.length, 1);

			});

		});

		describe("Binding with a specific cache", function() {

			it("should store the signature in that cache", function() {

				var cache = EventCache.createCache();
				EventCache.bind({}, "test", function() {}, cache);
				assert.equal(EventCache.status().additionalCaches[cache - 1].length, 1);

			});

		});

		describe("Binding and unbinding", function() {

			var i = 0, s, dispatcher = new EventDispatcher();

			it("should actually add the event listener", function() {

				s = EventCache.bind(dispatcher, "test", function(event) {

					++i;
					assert.equal(event.type, "test");

				});

			});

			it("should also remove the event listener properly", function() {

				dispatcher.dispatchEvent({type: "test"});
				EventCache.unbind(s);
				dispatcher.dispatchEvent({type: "test"});
				assert.equal(i, 1);

			});

		});

	});

});
