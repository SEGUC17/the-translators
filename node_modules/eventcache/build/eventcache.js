/**
 * eventcache v0.1.6 build Nov 06 2015
 * https://github.com/vanruesc/eventcache
 * Copyright 2015 Raoul van RÃ¼schen, Zlib
 */
'use strict';

/**
 * The caches.
 *
 * @property caches
 * @type Array
 * @private
 * @static
 */

var caches = [[]];

/**
 * Validates the arguments and tries to extract an event signature.
 *
 * @method extractSignature
 * @private
 * @static
 * @param {Object} args - The original arguments array from a call to add or remove.
 * @return {Array} The event signature.
 */

function extractSignature(args) {

	var signature = [null, null, null, null];

	if(args.length && (args.length >= 3 || args[0].length >= 3)) {

		if(args.length === 1) { args = args[0]; }

		signature[0] = args[0];
		signature[1] = args[1];
		signature[2] = args[2];
		signature[3] = (args.length === 4) ? args[3] : 0;

		if(signature[3] < 0 || signature[3] >= caches.length) {

		throw new Error("The given cache index is out of bounds.");

		}

	} else {

		throw new Error("Invalid arguments.");

	}

	return signature;
}

/**
 * Creates a new cache and returns its reference id.
 *
 * @method createCache
 * @return {Number} The index of the newly created cache.
 */

function createCache() { return caches.push([]) - 1; }

/**
 * Creates an event listener and adds its signature to the associated cache.
 *
 * @method bind
 * @static
 * @param {Object} obj - The object.
 * @param {String} event - The event name.
 * @param {Function} listener - The listener.
 * @param {Number} [cache=0] - The cache.
 */

function bind() {

	var s = extractSignature(arguments),
		obj = s[0], type = s[1], fn = s[2], cache = s[3];

	if(obj.addEventListener) {

		obj.addEventListener(type, fn, false);

	} else if(obj.attachEvent) {

		obj.attachEvent("on" + type, fn);

	} else {

		obj["on" + type] = fn;

	}

	caches[cache].push(s);
	return s;
}

/**
 * Unbinds an event and removes its signature from the associated cache.
 *
 * @method unbind
 * @static
 * @param {Object} obj - The object.
 * @param {String} event - The event name.
 * @param {Function} listener - The listener.
 * @param {Number} [cache=0] - The cache.
 */

function unbind() {

	var i, s = extractSignature(arguments),
		obj = s[0], type = s[1], fn = s[2], cache = s[3];

	for(i = caches[cache].length - 1; i >= 0; --i) {

		s = caches[cache][i];

		if(s[0] === obj && s[1] === type && s[2] === fn) {

			if(obj.removeEventListener) {

				obj.removeEventListener(type, fn, false);

			} else if(obj.detachEvent) {

				obj.detachEvent("on" + type, fn);

			} else {

				obj["on" + type] = null;

			}

			caches[cache].splice(i, 1);
			i = 0;

		}

	}

}

/**
 * Removes all event signatures from the given cache
 * and releases the respective event listeners.
 * Calling flush without specifying a cache will unbind
 * and remove all listeners in all caches. Empty caches
 * will then be dropped and can no longer be used.
 * Only the default cache will remain.
 *
 * @method flush
 * @static
 * @param {Number} [cache] - The index of the cache to flush. If not provided, all caches will be flushed.
 */

function flush(cache) {

	var i, len, j, reset = false;

	if(typeof cache !== "number" || isNaN(cache)) {

		cache = 0;
		len = caches.length;
		reset = true;

	} else {

		if(cache < 0) { cache = 0; }
		else if(cache >= caches.length) { cache = caches.length - 1; }
		len = cache + 1;

	}

	for(i = cache; i < len; ++i) {

		for(j = caches[i].length - 1; j >= 0; --j) {

			unbind(caches[i][j]);

		}

	}

	// Drop all caches except for the default one.
	if(reset) { caches.length = 1; }

}

/**
 * Provides insight into the internals.
 *
 * @method status
 * @static
 * @return {Object} The default cache and all additional caches.
 */

function status() {

	return {

		defaultCache: caches.slice(0, 1),
		additionalCaches: caches.slice(1)

	};

}

exports.createCache = createCache;
exports.bind = bind;
exports.unbind = unbind;
exports.flush = flush;
exports.status = status;